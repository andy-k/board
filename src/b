// wip

mod alphabet;
mod gdw;
mod matrix;

struct Board<'a, BC: BoardConfig, A: alphabet::Alphabet> {
    b: &'a [u8],
    bc: std::marker::PhantomData<BC>,
    a: std::marker::PhantomData<A>,
}

impl<'a, BC: BoardConfig, A: alphabet::Alphabet> Board<'a, BC, A> {
    #[inline(always)]
    fn new(b: &'a [u8]) -> Board<'a, BC, A> {
        Board {
            b,
            bc: std::marker::PhantomData,
            a: std::marker::PhantomData,
        }
    }
}

// never transposed
impl<'a, BC: BoardConfig, A: alphabet::Alphabet> std::ops::Index<RowCol> for Board<'a, BC, A> {
    type Output = u8;

    #[inline(always)]
    fn index(&self, RowCol(row, col): RowCol) -> &Self::Output {
        &self.b[((row as isize) * (BC::dim().cols as isize) + (col as isize)) as usize]
    }
}

impl<'a, BC: BoardConfig, A: alphabet::Alphabet> std::fmt::Debug for Board<'a, BC, A> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for row in 0..BC::dim().rows {
            write!(f, "{:2} [", row)?;
            for col in 0..BC::dim().cols {
                if col != 0 {
                    write!(f, " ")?;
                }
                write!(f, "{:02x}", self[RowCol(row, col)])?;
            }
            writeln!(f, "]")?;
        }
        Ok(())
    }
}

impl<'a, BC: BoardConfig, A: alphabet::Alphabet> std::fmt::Display for Board<'a, BC, A> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for row in 0..BC::dim().rows {
            write!(f, "{:2} [", row)?;
            for col in 0..BC::dim().cols {
                if col != 0 {
                    write!(f, " ")?;
                }
                write!(
                    f,
                    "{}",
                    A::from_board(self[RowCol(row, col)])
                        .unwrap_or_else(|| empty_label::<BC>(RowCol(row, col))),
                )?;
            }
            writeln!(f, "]")?;
        }
        Ok(())
    }
}

struct Q {
}


fn testbca<V: BCA>() {
  println!("rows={} alpha={}", V::BC::dim().rows, V::A::from_dag(1).unwrap());
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
testbca::<Q>();

    let gaddawg = {
        let args: Box<[String]> = std::env::args().collect();
        let default_filename = String::from("csw19.gdw");
        let filename = args.get(1).unwrap_or(&default_filename);
        let buf = std::fs::read(filename)?;
        gdw::from_bytes(&buf)
      };

    gdw::print_dawg::<alphabet::ENGLISH_ALPHABET>(&gaddawg);
    println!("{}", gdw::count_dawg(&gaddawg));

    let board = Board::<CommonBoard, alphabet::ENGLISH_ALPHABET>::new(
        b"\
\x0f\x04\x00\x00\x00\x00\x08\x01\x12\x0c\x0f\x14\x13\x00\x00\
\x06\x09\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x17\x00\x00\x00\
\x00\x14\x05\x05\x00\x07\x00\x00\x00\x00\x00\x09\x00\x00\x00\
\x00\x1a\x01\x18\x00\x12\x00\x00\x00\x00\x00\x03\x00\x00\x00\
\x00\x00\x14\x0f\x12\x09\x00\x00\x03\x00\x04\x05\x00\x00\x00\
\x00\x00\x0c\x00\x01\x0d\x00\x14\x15\x0e\x01\x00\x00\x00\x00\
\x00\x00\x19\x05\x0e\x00\x11\x09\x0e\x00\x08\x00\x00\x00\x00\
\x00\x00\x00\x16\x09\x02\x09\x13\x14\x00\x0c\x00\x00\x00\x00\
\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x09\x00\x00\x00\x00\
\x00\x00\x00\x0a\x01\x19\x00\x00\x00\x0e\x01\x00\x00\x00\x00\
\x00\x00\x00\x01\x0d\x05\x00\x00\x06\x01\x13\x00\x00\x00\x00\
\x00\x00\x00\x12\x05\x10\x00\x12\x15\x0e\x00\x00\x00\x00\x00\
\x00\x00\x0f\x00\x02\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\
\x00\x00\x17\x12\x01\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\
\x0f\x0b\x05\x00\x05\x09\x04\x05\x00\x00\x00\x00\x00\x00\x00\
",
    );

    println!("{}", board);
    println!("{:?}", board);

    Ok(())
}
